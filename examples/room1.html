<!DOCTYPE html>
<html lang="en">
<head>
<title>Reticulum | Room1</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style type="text/css">
	html, body {
		background-color: #000;
		margin: 0;
		padding: 0; 
		overflow: hidden;
	}
	.well {
   background-color: rgba(245, 245, 245, 0.4);
   font-size: 10px;
}
</style>
</head>
<body>
<div id="Message" width='100px'>
</div>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  BUFFER_SCALE: 0.5, // default: 1.0
};
</script>

<!-- THREE library, controls and effects -->
<script src="./js/lib/THREE55.js"></script>
<script src="./js/lib/three.js"></script>

<script src="js/lib/Detector.js"></script>
<script src="./js/lib/VRControls.js"></script>
<script src="./js/lib/VREffect.js"></script>
<!-- WebVR polyfill and manager -->
<script src="./js/lib/webvr-polyfill.js"></script>
<script src="./js/lib/webvr-manager.js"></script>
<!-- A simple gaze interaction manager for VR -->
<script src="../reticulum.js"></script>
<script>


// Setup three.js WebGL renderer
var renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
// Append the canvas element created by the renderer to document body element.
document.body.appendChild( renderer.domElement );
// custom global variables
var video, videoImage, videoImageContext, videoTexture;

//Create a three.js scene
var scene = new THREE.Scene();

//Camera
//Create a three.js camera
var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

//Apply VR headset positional data to camera.
var controls = new THREE.VRControls( camera );
controls.standing = true;

//Apply VR stereo rendering to renderer
var effect = new THREE.VREffect( renderer );
effect.setSize( window.innerWidth, window.innerHeight );

// Create a VR manager helper to enter and exit VR mode.
var manager = new WebVRManager( renderer, effect, {hideButton: false, isUndistorted: false} );


var hemiLight = new THREE.HemisphereLight(0x0000ff, 0x00ff00, 0.6);
hemiLight.position.set(0, 500, 0);

scene.add(hemiLight);
var boxGeometry = new THREE.BoxGeometry( 1, 1, 1 );
var planeGeometry = new THREE.PlaneGeometry( 0.8, 0.8 );
var sphereGeometry = new THREE.SphereGeometry( 1, 2, 2 );

//Initial Data
var sphere1 = [
	{
		"name": "main",
		"type": "sphere",
		"image_url": "../examples/images/Room1.jpg"	
	}
];


var initialObjects = [
	{
		"name": "exit_door",
		"type": "gaze",
		"x": -5.6,
		"y": 1,
		"rotY": 0,
		"z": -10,
		"texture": '../examples/images/exit.png'
	},
	{
		"name": "info",
		"type": "object",
		"x": .5,
		"y": 2,
		"rotY": 0,
		"z": -2,
		"texture": '../examples/images/deluxeroom.png'
	},
	{
		"name": "book",
		"type": "gaze",
		"x": 0,
		"y": -7,
		"rotY": 9.5,
		"z": -10,
		"texture": '../examples/images/money-bag.png'
	}
];


var bookData = [
	{
			"name": "book_confirm_msg",
			"type": "gaze",
			"x": 0,
			"y": -2,
			"rotY": 9.5,
			"z": -10,
			"texture": '../examples/images/booking.png'
		},
		{
			"name": "yes",
			"type": "gaze",
			"x": 1,
			"y": -4,
		"rotY": 9.5,
		"z": -10,
		"texture": '../examples/images/ok.png'
	},
	{
		"name": "no",
		"type": "gaze",
		"x": -1,
		"y": -4,
		"rotY": 9.5,
		"z": -10,
		"texture": '../examples/images/cancel.png'
	}
];


var paymentData = [
	{
			"name": "payment_success_msg",
			"type": "gaze",
			"x": -0.5,
			"y": 1,
			"rotY": 9.5,
			"z": -5,
			"texture": '../examples/images/bookingcomplete.png'
		},
		{
			"name": "continue",
			"type": "gaze",
			"x": .5,
			"y": 0,
			"rotY": 9.5,
			"z": -5,
			"texture": '../examples/images/continue.png'
		},
		{
			"name": "exit",
			"type": "gaze",
			"x": -1.5,
			"y": 0,
			"rotY": 9.5,
			"z": -5,
			"texture": '../examples/images/exitvr.png'
		}
];





//Initialize Scene
pointer();
init();


function draw(data){
//TODO GET data from backend, parse json to array of objects.
	for(i = 0; i < data.length; i++) {

		if(data[i].type == "sphere"){
			 addSphere(data[i].image_url, data[i].name);
		}else if(data[i].type == "gaze"){
			// addMesh(planeGeometry, data[i].x, data[i].y, data[i].name, data[i].rotY, data[i].z);
			var texture = THREE.ImageUtils.loadTexture(data[i].texture);
			addMesh(planeGeometry, data[i].x, data[i].y, data[i].name, data[i].rotY, data[i].z, texture);
		}else if(data[i].type == "object"){
			// addMesh(planeGeometry, data[i].x, data[i].y, data[i].name, data[i].rotY, data[i].z);
			var texture = THREE.ImageUtils.loadTexture(data[i].texture);
			addObject(planeGeometry, data[i].x, data[i].y, data[i].name, data[i].rotY, data[i].z, texture);
		}
	     
	}
}

function erase(data){
	for(i = 0; i < data.length; i++) {
		if(data[i].type == "sphere"){
			removeObject(data[i].name);
		}else if(data[i].type == "gaze"){
			removeReticulum(data[i].name);
		}
	}
}



function init(){

var pathname = window.location.pathname; // Returns path only
var urlhref      = window.location.href; 
var url = new URL(urlhref);
var url_value = url.searchParams.get("room");

// alert(url_value);

	if(url_value=='1'){
		draw(sphere1);
		draw(initialObjects);
		// draw(paymentData);
	}
}

function pointer(){
var mesh = new THREE.Mesh( new THREE.SphereGeometry( .05, 20, 3 ), new THREE.MeshNormalMaterial() );
//mesh.position.z = -50; // some negative number
mesh.rotation.copy( camera.rotation );
mesh.updateMatrix();
mesh.translateZ( -5 );
scene.add( camera );
camera.add( mesh );
}
function addSphere(textUrl, name){
// Create a texture-mapped cube and add it to the scene
    // First, create the texture map
    // Maya Scene Source â€“ fisheye image https://thefulldomeblog.com/2013/08/06/house-of-mirrors/
    // rendered with Domemaster3D
    // https://github.com/zicher3d-org/domemaster-stereo-shader/releases

    var textureUrl = textUrl;
    var loader = new THREE.TextureLoader();
    var map = loader.load( 
        // resource URL
        textureUrl
    );

    // Now, create a Basic material; pass in the map

    var material = new THREE.MeshBasicMaterial({ map: map, side:THREE.DoubleSide });

    // Create the sky sphere geometry
    var geometry = new THREE.SphereGeometry(15, 32, 32);
    // We're looking at the inside
    geometry.applyMatrix( new THREE.Matrix4().makeScale( -2, 1, 1 ) );

    // And put the geometry and material together into a mesh
    var sphere = new THREE.Mesh(geometry, material);
    sphere.rotation.y = -Math.PI / 2;
	sphere.name = name;
	// Finally, add the mesh to our scene
    scene.add(sphere);
    

//Called on each render loop
var duration = 10000; // ms
}

function addMesh(geo, posX, posY, name, rotY, zIndex, texture) {
	
    var cbmaterial = new THREE.MeshPhongMaterial({map: texture});
	
    var material = new THREE.MeshBasicMaterial({ map: texture, side:THREE.DoubleSide, transparent:true, opacity:0.8});

	var object = new THREE.Mesh( geo, material );
	object.name = name;
	object.position.x = posX;
	object.position.y = posY;
	object.rotation.y = rotY;
	object.transparent = true
	object.updateMatrix();
	object.translateZ(zIndex);

	scene.add( object );
	console.log("addMesh" + name);
	addReticulum(object, name);
}


function addObject(geo, posX, posY, name, rotY, zIndex, texture) {
	
    var cbmaterial = new THREE.MeshPhongMaterial({map: texture});
	
    var material = new THREE.MeshBasicMaterial({ map: texture, side:THREE.DoubleSide, transparent:true, opacity:0.8});

	var object = new THREE.Mesh( geo, material );
	object.name = name;
	object.position.x = posX;
	object.position.y = posY;
	object.rotation.y = rotY;
	object.transparent = true
	object.updateMatrix();
	object.translateZ(zIndex);

	scene.add( object );
	console.log("addMesh" + name);
	// addReticulum(object, name);
}

//Add Reticulum
	function addReticulum(object, itemToRemove){
	// *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	// track the object
	Reticulum.add( object, {
		onGazeOver: function(){
			// do something when user targets object
			
			//his.material.emissive.setHex( 0xffcc00 );
		},
		onGazeOut: function(){
			// do something when user moves reticle off targeted object
			//this.material.emissive.setHex( 0xcc0000 );
		},
		onGazeLong: function(){
			// do something user targetes object for specific time
			console.log("onGazeLong" + object.name);
			var name = object.name;
			actionEvent(name);
			
			
		},
		onGazeClick: function(){
			// have the object react when user clicks / taps on targeted object
			this.material.emissive.setHex( 0x00cccc * Math.random() );
		}
	});
	}
		//removeReticulum
		function removeReticulum(itemToRemove){
		var selectedObject = scene.getObjectByName(itemToRemove);
		scene.remove( selectedObject );
		Reticulum.remove(selectedObject);
		
		}
		//removeObject
		function removeObject(itemToRemove){
		var selectedObject = scene.getObjectByName(itemToRemove);
			scene.remove( selectedObject );
		
		}

//Action Manager
function actionEvent(name){
	console.log("actionEvent" + name);

	if(name=='book'){
		draw(bookData);
		erase(initialObjects);
	}else if(name=='no'){
		erase(bookData);
		draw(initialObjects);
	}else if(name=='exit_door'){
		//TODO go to lobby
	}else if(name=='yes'){
		erase(bookData);
		draw(paymentData);
	}else if(name=='continue'){
		erase(paymentData);
		draw(initialObjects);
	}else if(name=='exit'){
		//TODO go back to app
	}
}
// *******************************
// --- Reticulum ---
// initiate Reticulum so it loads up 
Reticulum.init(camera, {
	proximity: false,
	clickevents: true,
	reticle: {
		visible: true,
		restPoint: 1000, //Defines the reticle's resting point when no object has been targeted
		color: 0xcc00cc,
		innerRadius: 0.002,
		outerRadius: 0.005,
		hover: {
			color: 0x00cccc,
			innerRadius: 0.02,
			outerRadius: 0.024,
			speed: 5,
			vibrate: 50 //Set to 0 or [] to disable
		}
	},
	fuse: {
		visible: true,
		duration: 2.5,
		color: 0x00fff6,
		innerRadius: 0.045,
		outerRadius: 0.06,
		vibrate: 0, //Set to 0 or [] to disable
		clickCancelFuse: false //If users clicks on targeted object fuse is canceled
	}
});

// IMPORTANT add camera to cene if you want to see a reticle 
scene.add(camera);

function addText(name, text, coordinateXpos, coordinateYpos, contentWidth, rotY){
// add 3D text
	var materialFront = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
	var materialSide = new THREE.MeshBasicMaterial( { color: 0x000088 } );
	var materialArray = [ materialFront, materialSide ];
	
	var spritey = makeTextSprite( text, 
		{ fontsize: 12, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0} } );
		
	spritey.name = name;
	spritey.position.x = coordinateXpos;
	spritey.position.y = coordinateYpos;
	spritey.rotation.y = rotY;
	spritey.updateMatrix();
	spritey.translateZ( -2 );
	scene.add( spritey );
	
}


function createVideo(){
	///////////
	// VIDEO //
	///////////
		
	// create the video element
	video = document.createElement( 'video' );
	// video.id = 'video';
	// video.type = ' video/ogg; codecs="theora, vorbis" ';
	video.src = "videos/sintel.ogv";
	video.load(); // must call after setting/changing source
	video.play();
		
	// alternative method -- 
	// create DIV in HTML:
	// <video id="myVideo" autoplay style="display:none">
	//		<source src="videos/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
	// </video>
	// and set JS variable:
	// video = document.getElementById( 'myVideo' );
		
	videoImage = document.createElement( 'canvas' );
	videoImage.width = 1000;
	videoImage.height = 600;

	videoImageContext = videoImage.getContext( '2d' );
	// background color if no video present
	videoTexture = new THREE.Texture( videoImage );
	videoTexture.minFilter = THREE.LinearFilter;
	videoTexture.magFilter = THREE.LinearFilter;
		
	var movieMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: true, side:THREE.DoubleSide } );
	// the geometry on which the movie will be displayed;
	// 		movie image will be scaled to fit these dimensions.
	var movieGeometry = new THREE.PlaneGeometry( 80, 4);
	var movieScreen = new THREE.Mesh( movieGeometry, movieMaterial );
	movieScreen.translateZ( -9 );
	scene.add(movieScreen);
	camera.position.set(0,200,300);
	camera.lookAt(movieScreen.position);

}


function makeTextSprite( message, parameters )
{
	if ( parameters === undefined ) parameters = {};
	
	var fontface = parameters.hasOwnProperty("fontface") ? 
		parameters["fontface"] : "Arial";
	
	var fontsize = parameters.hasOwnProperty("fontsize") ? 
		parameters["fontsize"] : 18;
	
	var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
		parameters["borderThickness"] : 1;
	
	var borderColor = parameters.hasOwnProperty("borderColor") ?
		parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	
	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
		parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
	
	var spriteAlignment = THREE.SpriteAlignment.topLeft;
		
	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = "Bold " + fontsize + "px " + fontface;
    
	// get size data (height depends only on font size)
	var metrics = context.measureText( message );
	var textWidth = metrics.width;
	// background color
	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
								  + backgroundColor.b + "," + backgroundColor.a + ")";
	// border color
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
								  + borderColor.b + "," + borderColor.a + ")";

	context.lineWidth = borderThickness;
	roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness * 2, fontsize * 1.4 + borderThickness, 10);
	// 1.4 is extra height factor for text below baseline: g,j,p,q.
	
	// text color
	context.fillStyle = "rgba(0, 0, 0, 1.0)";

	context.fillText( message, borderThickness, fontsize + borderThickness);
	
	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas) 
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial( 
		{ map: texture, useScreenCoordinates: false, alignment: spriteAlignment } );
	var sprite = new THREE.Sprite( spriteMaterial );
	
	return sprite;	
}

// function for drawing rounded rectangles
function roundRect(ctx, x, y, w, h, r) 
{
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    ctx.fill();
	ctx.stroke();   
}

function animate(timestamp) {
	// *******************************
	// --- Reticulum ---
	// keep checking if user is looking at any tracked objects
	Reticulum.update();
	
	controls.update();
	camera.updateMatrixWorld(); // Required to stop ghosting - must be placed before render update
	manager.render(scene, camera, timestamp);

	requestAnimationFrame(animate);
	
}
animate();
</script>
</body>
</html>